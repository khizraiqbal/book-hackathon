"use strict";(globalThis.webpackChunkbook_website=globalThis.webpackChunkbook_website||[]).push([[686],{7087(n,e,i){i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var t=i(4848),o=i(8453);const a={title:"Chapter 3 - Kinematics and Mathematical Foundations \u2013 Forward/Inverse Kinematics, Transformations, and Motion Planning",sidebar_position:3},s="Chapter 3: Kinematics and Mathematical Foundations \u2013 Forward/Inverse Kinematics, Transformations, and Motion Planning",r={id:"module1/chapter3_kinematics_mathematical_foundations",title:"Chapter 3 - Kinematics and Mathematical Foundations \u2013 Forward/Inverse Kinematics, Transformations, and Motion Planning",description:"Introduction to Robot Kinematics",source:"@site/docs/module1/chapter3_kinematics_mathematical_foundations.md",sourceDirName:"module1",slug:"/module1/chapter3_kinematics_mathematical_foundations",permalink:"/docs/module1/chapter3_kinematics_mathematical_foundations",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module1/chapter3_kinematics_mathematical_foundations.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Chapter 3 - Kinematics and Mathematical Foundations \u2013 Forward/Inverse Kinematics, Transformations, and Motion Planning",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Chapter 2 - Fundamentals of Humanoid Robotics \u2013 History, Components, and Applications",permalink:"/docs/module1/chapter2_fundamentals_humanoid_robots"},next:{title:"Chapter 1 - Introduction to Digital Twins (Gazebo & Unity)",permalink:"/docs/module2/chapter1_introduction_to_digital_twins"}},l={},c=[{value:"Introduction to Robot Kinematics",id:"introduction-to-robot-kinematics",level:2},{value:"Forward Kinematics",id:"forward-kinematics",level:2},{value:"Definition and Purpose",id:"definition-and-purpose",level:3},{value:"Mathematical Representation",id:"mathematical-representation",level:3},{value:"Denavit-Hartenberg (DH) Convention",id:"denavit-hartenberg-dh-convention",level:3},{value:"Application to Humanoid Robots",id:"application-to-humanoid-robots",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:2},{value:"Definition and Challenges",id:"definition-and-challenges",level:3},{value:"Analytical vs. Numerical Methods",id:"analytical-vs-numerical-methods",level:3},{value:"Jacobian Matrix",id:"jacobian-matrix",level:3},{value:"Singularity and Redundancy",id:"singularity-and-redundancy",level:3},{value:"Coordinate Systems and Transformations",id:"coordinate-systems-and-transformations",level:2},{value:"World Coordinate System",id:"world-coordinate-system",level:3},{value:"Joint Coordinate Systems",id:"joint-coordinate-systems",level:3},{value:"End-Effector Coordinate System",id:"end-effector-coordinate-system",level:3},{value:"Transformation Matrices",id:"transformation-matrices",level:3},{value:"Motion Planning",id:"motion-planning",level:2},{value:"Configuration Space (C-Space)",id:"configuration-space-c-space",level:3},{value:"Path Planning in Joint Space vs. Cartesian Space",id:"path-planning-in-joint-space-vs-cartesian-space",level:3},{value:"Trajectory Generation",id:"trajectory-generation",level:3},{value:"Applications in Humanoid Robotics",id:"applications-in-humanoid-robotics",level:2},{value:"Walking Pattern Generation",id:"walking-pattern-generation",level:3},{value:"Manipulation Tasks",id:"manipulation-tasks",level:3},{value:"Whole-Body Control",id:"whole-body-control",level:3},{value:"Computational Considerations",id:"computational-considerations",level:2},{value:"Real-Time Requirements",id:"real-time-requirements",level:3},{value:"Numerical Stability",id:"numerical-stability",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h1,{id:"chapter-3-kinematics-and-mathematical-foundations--forwardinverse-kinematics-transformations-and-motion-planning",children:"Chapter 3: Kinematics and Mathematical Foundations \u2013 Forward/Inverse Kinematics, Transformations, and Motion Planning"}),"\n",(0,t.jsx)(e.h2,{id:"introduction-to-robot-kinematics",children:"Introduction to Robot Kinematics"}),"\n",(0,t.jsx)(e.p,{children:"Robot kinematics is the study of motion in robotic systems, specifically the relationship between joint positions and the position and orientation of the robot's end-effectors. In humanoid robotics, kinematics is fundamental to understanding how the robot's various joints work together to achieve desired movements and positions. This mathematical foundation enables engineers to program robots to perform complex tasks like reaching, walking, and manipulating objects."}),"\n",(0,t.jsx)(e.p,{children:"Kinematics in humanoid robots involves both forward kinematics (determining end-effector position from joint angles) and inverse kinematics (determining joint angles to achieve a desired end-effector position). These concepts are essential for creating natural, coordinated movements that mimic human motion patterns."}),"\n",(0,t.jsx)(e.h2,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,t.jsx)(e.h3,{id:"definition-and-purpose",children:"Definition and Purpose"}),"\n",(0,t.jsx)(e.p,{children:"Forward kinematics is the process of calculating the position and orientation of a robot's end-effector given the joint angles and link parameters. For humanoid robots, this involves transforming coordinates from the base of the robot through each joint to the end of each limb."}),"\n",(0,t.jsx)(e.h3,{id:"mathematical-representation",children:"Mathematical Representation"}),"\n",(0,t.jsx)(e.p,{children:"The position and orientation of each link in a humanoid robot can be represented using homogeneous transformation matrices. For a chain of n joints, the transformation from the base to the end-effector is given by:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"T = A\u2081(\u03b8\u2081) \xd7 A\u2082(\u03b8\u2082) \xd7 ... \xd7 A\u2099(\u03b8\u2099)\n"})}),"\n",(0,t.jsx)(e.p,{children:"Where A\u1d62(\u03b8\u1d62) represents the transformation matrix for the i-th joint with angle \u03b8\u1d62."}),"\n",(0,t.jsx)(e.h3,{id:"denavit-hartenberg-dh-convention",children:"Denavit-Hartenberg (DH) Convention"}),"\n",(0,t.jsx)(e.p,{children:"The DH convention provides a systematic method for assigning coordinate frames to the joints and links of a humanoid robot:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"z-axis"}),": Along the axis of motion of the joint"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"x-axis"}),": Along the common normal between the previous and current z-axes"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"y-axis"}),": Completes the right-handed coordinate system"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"The DH parameters include:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"a\u1d62"}),": Link length (distance along x\u1d62 from z\u1d62 to z\u1d62\u208a\u2081)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"\u03b1\u1d62"}),": Link twist (angle from z\u1d62 to z\u1d62\u208a\u2081 about x\u1d62)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"d\u1d62"}),": Link offset (distance along z\u1d62 from x\u1d62\u208b\u2081 to x\u1d62)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"\u03b8\u1d62"}),": Joint angle (angle from x\u1d62\u208b\u2081 to x\u1d62 about z\u1d62)"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"application-to-humanoid-robots",children:"Application to Humanoid Robots"}),"\n",(0,t.jsx)(e.p,{children:"For humanoid robots, forward kinematics must be calculated for multiple chains:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Left arm: from torso to left hand"}),"\n",(0,t.jsx)(e.li,{children:"Right arm: from torso to right hand"}),"\n",(0,t.jsx)(e.li,{children:"Left leg: from torso to left foot"}),"\n",(0,t.jsx)(e.li,{children:"Right leg: from torso to right foot"}),"\n",(0,t.jsx)(e.li,{children:"Head: from torso to head orientation"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,t.jsx)(e.h3,{id:"definition-and-challenges",children:"Definition and Challenges"}),"\n",(0,t.jsx)(e.p,{children:"Inverse kinematics (IK) is the reverse process of forward kinematics, determining the joint angles required to achieve a desired end-effector position and orientation. This is significantly more complex than forward kinematics and often has multiple solutions or no exact solution."}),"\n",(0,t.jsx)(e.h3,{id:"analytical-vs-numerical-methods",children:"Analytical vs. Numerical Methods"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Analytical Methods"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Closed-form solutions for simple kinematic chains"}),"\n",(0,t.jsx)(e.li,{children:"Fast computation but limited to specific configurations"}),"\n",(0,t.jsx)(e.li,{children:"Suitable for arms with spherical wrists"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Numerical Methods"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Iterative approaches like Jacobian-based methods"}),"\n",(0,t.jsx)(e.li,{children:"Can handle complex kinematic chains"}),"\n",(0,t.jsx)(e.li,{children:"More computationally intensive but more general"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"jacobian-matrix",children:"Jacobian Matrix"}),"\n",(0,t.jsx)(e.p,{children:"The Jacobian matrix relates joint velocities to end-effector velocities:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"v = J(\u03b8) \xd7 \u03b8\u0307\n"})}),"\n",(0,t.jsx)(e.p,{children:"Where:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"v is the end-effector velocity vector"}),"\n",(0,t.jsx)(e.li,{children:"J(\u03b8) is the Jacobian matrix"}),"\n",(0,t.jsx)(e.li,{children:"\u03b8\u0307 is the joint velocity vector"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"For inverse kinematics, the joint velocities can be computed as:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"\u03b8\u0307 = J\u207b\xb9(\u03b8) \xd7 v\n"})}),"\n",(0,t.jsx)(e.p,{children:"When the Jacobian is not square or is singular, the pseudoinverse is used:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"\u03b8\u0307 = J\u207a(\u03b8) \xd7 v\n"})}),"\n",(0,t.jsx)(e.h3,{id:"singularity-and-redundancy",children:"Singularity and Redundancy"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Singularities"})," occur when the Jacobian loses rank, making the inverse undefined. At singularities, the robot loses one or more degrees of freedom."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Redundant robots"})," have more degrees of freedom than required for a task, providing multiple solutions to the IK problem. Humanoid robots are typically redundant, allowing for additional optimization criteria like obstacle avoidance or energy efficiency."]}),"\n",(0,t.jsx)(e.h2,{id:"coordinate-systems-and-transformations",children:"Coordinate Systems and Transformations"}),"\n",(0,t.jsx)(e.h3,{id:"world-coordinate-system",children:"World Coordinate System"}),"\n",(0,t.jsx)(e.p,{children:"The global reference frame for the humanoid robot, typically located at the robot's base or a fixed point in the environment."}),"\n",(0,t.jsx)(e.h3,{id:"joint-coordinate-systems",children:"Joint Coordinate Systems"}),"\n",(0,t.jsx)(e.p,{children:"Each joint has its own coordinate system, defined according to the DH convention or another systematic approach."}),"\n",(0,t.jsx)(e.h3,{id:"end-effector-coordinate-system",children:"End-Effector Coordinate System"}),"\n",(0,t.jsx)(e.p,{children:"The coordinate system attached to the robot's end-effector (hand, foot, etc.), used to specify desired positions and orientations."}),"\n",(0,t.jsx)(e.h3,{id:"transformation-matrices",children:"Transformation Matrices"}),"\n",(0,t.jsx)(e.p,{children:"Homogeneous transformation matrices combine rotation and translation in a 4\xd74 matrix:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"T = [R  p]\n    [0  1]\n"})}),"\n",(0,t.jsx)(e.p,{children:"Where R is a 3\xd73 rotation matrix and p is a 3\xd71 position vector."}),"\n",(0,t.jsx)(e.h2,{id:"motion-planning",children:"Motion Planning"}),"\n",(0,t.jsx)(e.h3,{id:"configuration-space-c-space",children:"Configuration Space (C-Space)"}),"\n",(0,t.jsx)(e.p,{children:"The configuration space represents all possible joint configurations of the robot. For a humanoid robot with n joints, C-space is typically n-dimensional."}),"\n",(0,t.jsx)(e.h3,{id:"path-planning-in-joint-space-vs-cartesian-space",children:"Path Planning in Joint Space vs. Cartesian Space"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Joint Space Planning"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Plan trajectories in joint angle space"}),"\n",(0,t.jsx)(e.li,{children:"Avoids IK calculations during execution"}),"\n",(0,t.jsx)(e.li,{children:"May result in unpredictable Cartesian paths"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Cartesian Space Planning"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Plan trajectories in end-effector space"}),"\n",(0,t.jsx)(e.li,{children:"Ensures desired Cartesian path is followed"}),"\n",(0,t.jsx)(e.li,{children:"Requires continuous IK calculations"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"trajectory-generation",children:"Trajectory Generation"}),"\n",(0,t.jsx)(e.p,{children:"Smooth trajectories are essential for natural humanoid movement:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Polynomial interpolation"}),": Ensures continuous position, velocity, and acceleration"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Spline curves"}),": Provide smooth paths through multiple waypoints"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Velocity profiles"}),": Trapezoidal or S-curve profiles for smooth motion"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"applications-in-humanoid-robotics",children:"Applications in Humanoid Robotics"}),"\n",(0,t.jsx)(e.h3,{id:"walking-pattern-generation",children:"Walking Pattern Generation"}),"\n",(0,t.jsx)(e.p,{children:"Kinematic principles are essential for generating stable walking patterns:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Inverse kinematics for foot placement"}),"\n",(0,t.jsx)(e.li,{children:"Center of mass control"}),"\n",(0,t.jsx)(e.li,{children:"Balance maintenance during gait"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"manipulation-tasks",children:"Manipulation Tasks"}),"\n",(0,t.jsx)(e.p,{children:"For tasks requiring reaching and manipulation:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"IK for end-effector positioning"}),"\n",(0,t.jsx)(e.li,{children:"Redundancy resolution for obstacle avoidance"}),"\n",(0,t.jsx)(e.li,{children:"Coordination between multiple limbs"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"whole-body-control",children:"Whole-Body Control"}),"\n",(0,t.jsx)(e.p,{children:"Advanced humanoid robots use kinematic models for:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Posture optimization"}),"\n",(0,t.jsx)(e.li,{children:"Force distribution"}),"\n",(0,t.jsx)(e.li,{children:"Coordinated multi-limb movements"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"computational-considerations",children:"Computational Considerations"}),"\n",(0,t.jsx)(e.h3,{id:"real-time-requirements",children:"Real-Time Requirements"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots require kinematic calculations to be performed in real-time:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Forward kinematics: typically 1-10 ms"}),"\n",(0,t.jsx)(e.li,{children:"Inverse kinematics: 10-100 ms depending on complexity"}),"\n",(0,t.jsx)(e.li,{children:"Optimization for embedded systems"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"numerical-stability",children:"Numerical Stability"}),"\n",(0,t.jsx)(e.p,{children:"Kinematic calculations must be numerically stable to prevent:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Drift in position estimates"}),"\n",(0,t.jsx)(e.li,{children:"Singularities causing control failures"}),"\n",(0,t.jsx)(e.li,{children:"Accumulation of numerical errors"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(e.p,{children:"Kinematics and mathematical foundations form the core of humanoid robot control and motion generation. Understanding both forward and inverse kinematics is essential for creating natural, coordinated movements that enable humanoid robots to perform complex tasks in human environments. The mathematical tools developed for kinematics enable engineers to program robots with human-like capabilities while maintaining computational efficiency for real-time operation."}),"\n",(0,t.jsx)(e.p,{children:"As humanoid robotics continues to advance, these fundamental principles remain essential for developing more sophisticated and capable robots that can interact effectively with humans and their environments."})]})}function h(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>s,x:()=>r});var t=i(6540);const o={},a=t.createContext(o);function s(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);